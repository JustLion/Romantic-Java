### 1、 既然有GC机制，为什么还会有内存泄漏的情况？
1. 在实际开发中，可能会存在无用但是可达的对象，这些对象不能被GC回收，因此也会造成内存泄漏的发生

### 2、 Java中为什么会有GC机制？
1. 安全性考虑
2. 减少内存泄漏
3. 减少程序员的工作量

### 3、 对于Java的GC哪些内存需要回收？
1. 程序计数器(`Program Counter Register`)、虚拟机栈(`VM Stack`)、本地方法栈(`Native Method Stack`)、方法区(`Method Area`)、堆(`Heap`)
2. `GC`主要进行回收的内存是`JVM`中的方法区和堆

### 4、 Java的GC什么时候回收垃圾？
1. 如何判断一个对象已死去？可达性分析，所有生成的对象都是一个称为“`GC Roots`”的根的子树。从`GC Roots`
开始向下搜索，搜索所经过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链可达时，就是说这个对象是不可达的，也就是应该被`GC`回收了
2. 强引用：只要强引用还在，`GC`永远不会回收掉引用的对象
3. 软引用：还有用非必需的对象，在系统将会发生内存溢出之前，会把这些对象列入回收范围进行二次回收
4. 弱引用：弱引用的对象只能生存在下次`GC`之前，`GC`工作时，无论内存足够都会回收
5. 虚引用：随时都会被回收

### 5、 常见的内存溢出原因
1. 内存中加载的数据量过于庞大，如一次从数据库取过多数据
2. 集合类中有对对象的引用，使用完未清空，使用JVM不能回收
3. 代码中存在死循环或循环过多重复的对象实体
4. 使用第三方软件中的`BUG`
5. 启动参数内存值设定的过小

### 6、 内存溢出的解决方案
1. 修改JVM的启动参数，直接增加内存（修改`-Xms， -Xmx`参数）
2. 检查错误日志，查看“`OutOfMemory`”错误前是否有其它异常或错误。
3. 对代码进行走查和分析，找出可能发生内存溢出的位置

### 7、 HotSpot JVM 后台运行的系统进程有哪些？
1. 虚拟机线程（VM thread）：这个线程等待jvm到达安全点操作出现，这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要jvm
位于安全点。这些操作类型有：stop the world 垃圾回收，线程栈 dump ，线程暂停，线程偏向锁（biased locking）解除。
2. 周期性任务线程：这线程负责定时器事件（也就是中断），用来调度周期性执行的操作。
3. GC 线程：这些线程支持 jvm 中不同的垃圾回收活动
4. 编译器线程：这些线程在运行时将字节码动态编译成本地平台相关的机器码
5. 信号分发线程：这个线程接收发送到 jvm 的信号并调用适当的 jvm 方法处理

### 8、 JVM 内存区域
1. 程序计数器（线程私有）：
    1. 一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。
    2. 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。
    3. 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。
2. 虚拟机栈（线程私有）：
    1. 是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
    2. 栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。 栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。
3. 本地方法区（线程私有）：
    1. 本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。
4. 堆（Heap-线程共享） -运行时数据区
    1. 是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。
5. 方法区/永久代（线程共享）：
    1. 即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。
    2. 运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。
    
### 9、 JVM运行时内存
1. 新生代：是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、 ServivorFrom、 ServivorTo 三个区。
    1. Eden 区：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
    2. ServivorFrom：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
    3. ServivorTo：保留了一次 MinorGC 过程中的幸存者
2. 老年代
    1. 主要存放应用程序中生命周期长的内存对象。
    2. 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。
    3. MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 MajorGC 的耗时比较长，因为要扫描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。
3. 永久代
    1. 指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。
    2. 在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入 nativememory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。

### 10、 MinorGC 的过程（复制->清空->互换）
1. MinorGC 采用复制算法
2. eden、 servicorFrom 复制到 ServicorTo，年龄+1
3. 清空 eden、 servicorFrom中的对象
4. ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。

### 11、 如何确定垃圾
1. 引用计数法：一个对象如果没有任何与之关联的引用， 即他们的引用计数都不为 0， 则说明对象不太可能再被用到，那么这个对象就是可回收对象。
2. 可达性分析：解决循环引用问题，所有生成的对象都是一个称为“GC Roots”的根的子树。从 GC Roots
 开始向下搜索，搜索所经过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链可达时，就是说这个对象是不可达的。不可达对象变为可回收对象至少要经过两次标记过程
 
 ### 12、 垃圾回收算法
 1. 标记清除算法
 2. 复制算法
 3. 标记整理算法
 4. 分代收集算法
