### 1、 既然有GC机制，为什么还会有内存泄漏的情况？
1. 在实际开发中，可能会存在无用但是可达的对象，这些对象不能被GC回收，因此也会造成内存泄漏的发生
### 2、 Java中为什么会有GC机制？
1. 安全性考虑
2. 减少内存泄漏
3. 减少程序员的工作量
### 3、 对于Java的GC哪些内存需要回收？
1. 程序计数器(`Program Counter Register`)、虚拟机栈(`VM Stack`)、本地方法栈(`Native Method Stack`)、方法区(`Method Area`)、堆(`Heap`)
2. `GC`主要进行回收的内存是`JVM`中的方法区和堆
### 4、 Java的GC什么时候回收垃圾？
1. 如何判断一个对象已死去？可达性分析，所有生成的对象都是一个称为“`GC Roots`”的根的子树。从`GC Roots`
开始向下搜索，搜索所经过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链可达时，就是说这个对象是不可达的，也就是应该被`GC`回收了
2. 强引用：只要强引用还在，`GC`永远不会回收掉引用的对象
3. 软引用：还有用非必需的对象，在系统将会发生内存溢出之前，会把这些对象列入回收范围进行二次回收
4. 弱引用：弱引用的对象只能生存在下次`GC`之前，`GC`工作时，无论内存足够都会回收
5. 虚引用：随时都会被回收
### 5、 常见的内存溢出原因
1. 内存中加载的数据量过于庞大，如一次从数据库取过多数据
2. 集合类中有对对象的引用，使用完未清空，使用JVM不能回收
3. 代码中存在死循环或循环过多重复的对象实体
4. 使用第三方软件中的`BUG`
5. 启动参数内存值设定的过小
### 6、 内存溢出的解决方案
1. 修改JVM的启动参数，直接增加内存（修改`-Xms， -Xmx`参数）
2. 检查错误日志，查看“`OutOfMemory`”错误前是否有其它异常或错误。
3. 对代码进行走查和分析，找出可能发生内存溢出的位置
### 7、 HTTP/1.0和HTTP/1.1的区别
1. `HTTP/1.0`默认使用的是短连接
2. `HTTP/1.1`默认使用的是长连接
### 8、 GET和POST的区别
1. `GET`请求的数据会附在`url`后以`?`分隔。`POST`则把提交的数据放置在`HTTP`包的包体中
2. `GET`请求提交的数据最多只能是1024字节，因为`url`长度的限制。理论上`POST`没有限制，可以上传较大数据
3. `POST`的安全性比`GET`高
### 9、 HTTP重定向和请求转发的区别
1. 本质区别：转发是服务器行为，重定向是客户端行为
2. 重定向特点：两次请求，浏览器地址发生变化，可以访问自己`web`之外的资源，传输的数据会丢失
3. 请求转发特点：一次请求，浏览器地址不变，访问的是自身的`web`资源，传输的数据不会丢失。
### 10、 Cookie和Session的区别？
1. 无论客户端怎么设置，`session`都能正常工作，但是当客户端禁用`cookie`时将无法使用`cookie`
2. 在存储数据量方面，`session`能够存储任意的`java`对象，`cookie`只能存储`String`类型的对象
### 11、 Session对象如何实现
1. 服务器端的`session`复制
2. `session`复制（用户过大时就是灾难）
3. `redis`和`cookie`实现`session`共享
### 12、 单点登录中，cookie被禁用了怎么办？
1. 单点登录实现原理是后端生成一个`sessionID`，然后设置到`cookie`，后面所有的请求都会带上`cookie`，然后服务端从`cookie`里获取`sessionID`，再查询用户信息，所以单点登录的实质是`sessionID`。所以如果`cookie`被禁用，可以通过`HTTP`
请求头来传输，但是这个请求头不会像`cookie`一样自动携带，需要手工处理。
